# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
# 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

import itertools
import math


def problem12_v2(n):

    i = 1
    while True:
        triangle = i * (i+1) / 2
        limit = int(math.sqrt(triangle))
        num_divisors = 0
        for j in range(1, limit):
            if triangle % j == 0:
                num_divisors += 2  # one for this factor and one for its counterpart
                if num_divisors >= n:
                    return triangle
        i += 1


# tried to do some crazy shit with prime factors which does not work, unsurprisingly
# but anyway the prime factors function is useful and the combinatorics were interesting
def problem12(n):

    i = 1
    while True:
        triangle = i * (i+1) / 2
        print triangle
        pf = prime_factors(triangle)
        num_divisors = 2
        test = []
        print pf
        for length in range(1, len(pf)):
            combos = list(itertools.combinations(pf, length))
            test.extend(combos)
            num_divisors += len(combos)
            if num_divisors >= n:
                print test
                return (triangle, num_divisors)
        i += 1


def prime_factors(x):

    all_primes = [True] * (x/2 + 1)

    if len(all_primes) > 0:
        all_primes[0] = False
    if len(all_primes) > 1:
        all_primes[1] = False
    if len(all_primes) > 2:
        all_primes[2] = True

    factors = []
    while x > 1 and x % 2 == 0:
        x /= 2
        factors.append(2)

    # set all even numbers to False
    all_primes[4::2] = [False] * (len(all_primes[4::2]))

    # iterate through all the potential primes
    for i in xrange(3, len(all_primes), 2):
        if not all_primes[i]:
            continue

        while x % i == 0:
            x /= i
            factors.append(i)
        all_primes[i * 2::i] = [False] * (len(all_primes[i * 2::i]))

    return factors


print problem12_v2(500)